# -*- coding: utf-8 -*-
"""LicenciasMedicas_Limpias_Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qbf-9DX0hyxNBx7GM3JScnwYJ_w93wgj
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Limpieza e integración de datos de licencias médicas Rúbrica 2

## Integrantes


1.   Franco López
2.   Jairo Sepúlveda
3.   Danilo Ramírez



**Objetivos:**
- Cargar y explorar el dataset de licencias médicas.
- Integrar datos externos de población para análisis de tasas.
- Identificar y tratar valores nulos.
- Convertir tipos de datos apropiadamente.
- Normalizar, renombrar y seleccionar columnas.
- Realizar EDA con estadísticas descriptivas y visualizaciones.

"""

# Importar librerías
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive

# Configuración de visualización
plt.style.use('ggplot')
sns.set_palette("pastel")
pd.set_option('display.max_columns', None)

drive.mount('/content/drive')

"""## Integración de datos
Carga de datos, Concatenación, Renombrado y Limpieza Inicial

"""

# Cargar datasets
df_2025 = pd.read_csv(
    '/content/drive/MyDrive/dataset_Licencias_Medicas_2025t1.txt',
    sep='|',
    encoding='latin-1',
    low_memory=False,
    on_bad_lines='skip'
)

df_2020 = pd.read_csv(
    '/content/drive/MyDrive/Licencias_Medicas_2020t1.txt',
    sep='|',
    encoding='latin-1',
    low_memory=False,
    on_bad_lines='skip'
)

df_2022 = pd.read_csv(
    '/content/drive/MyDrive/Licencias_Medicas_2022t1.txt',
    sep='|',
    encoding='latin-1',
    low_memory=False,
    on_bad_lines='skip'
)

# Asignar nombres de columnas
columnas_licencias = [
    "CodigoIsapre", "FechaInformacion", "RunTrabajador", "FechaEmisionLicencia",
    "NumeroDias", "FechaInicioReposo", "EdadTrabajador", "SexoTrabajador",
    "ActividadLaboral", "Ocupacion", "TipoLicencia", "CaracteristicasReposo",
    "RunProfesional", "TipoProfesional", "TipoLicenciaContraloria",
    "NumeroDiasAutorizados", "DiagnosticoPrincipal", "TipoResolucion", "Periodo",
    "ReposoAutorizado", "DerechoSubsidio", "FechaRecepcionIsapre",
    "FechaResolucionIsapre", "FechaRecepcionEmpleador", "Region",
    "CalidadTrabajador", "EntidadPagadora", "NumeroDiasPagar",
    "MontoSubsidioLiquido", "MontoAportePrevisionalIsapre", "FechaInicioPago",
    "Recuperabilidad", "FechaConcepcion", "MontoAportePrevisionalPensiones",
    "OtrosDiagnosticos", "RunHijo", "LugarReposo", "CausaRechazoModificacion",
    "NumeroDiasPreviosAutorizados", "FechaPrimeraAfiliacionPrevisional",
    "FechaContratoTrabajo", "MontoBaseCalculoSubsidio", "RutEmpleador",
    "FechaNacimientoHijo", 'eliminar'
]

df_2025.columns = columnas_licencias
df_2020.columns = columnas_licencias
df_2022.columns = columnas_licencias

# Eliminamos columna residual
df_2025.drop(columns=['eliminar'], inplace=True)
df_2020.drop(columns=['eliminar'], inplace=True)
df_2022.drop(columns=['eliminar'], inplace=True)

# Concatenar todos los años en un solo dataframe
df_concatenado = pd.concat([df_2020, df_2022, df_2025], ignore_index=True)

print("Tamaño del DataFrame concatenado:", df_concatenado.shape)
print("\nPrimeras filas del DataFrame concatenado:")
display(df_concatenado.head())

"""## Tratamiento de valores nulos
Identificación y estrategia de imputación o eliminación con justificación.
"""

# Conteo de valores nulos por columna
valores_nulos = df_concatenado.isnull().sum()
print("Valores nulos por columna:")
print(valores_nulos)

#Tratamos valores nulos
df_concatenado.dropna(subset=['OtrosDiagnosticos'], inplace=True)

# Porcentaje de nulos por columna (visual)
porcentaje_nulos = df_concatenado.isnull().mean() * 100
print("\nPorcentaje de valores nulos por columna:")
print(porcentaje_nulos)

"""## Justificación de tratamiento de valores nulos

1.  **Naturaleza de la columna `OtrosDiagnosticos`:** Esta columna contiene información adicional sobre diagnósticos médicos que, si bien pueden complementar el `DiagnosticoPrincipal`, no son esenciales para la mayoría de los análisis generales de licencias médicas (como duración, edad del trabajador, tipo de licencia, etc.). Si un registro carece de esta información, es probable que el `DiagnosticoPrincipal` sea suficiente para identificar la causa principal de la licencia.

2.  **Proporción de nulos en `OtrosDiagnosticos`:** Se debe evaluar qué porcentaje de los datos tienen valores nulos en esta columna. Si el porcentaje es relativamente bajo, eliminar esas filas podría ser una estrategia aceptable para mantener la calidad de los datos restantes sin una pérdida significativa de información general. Si el porcentaje fuera muy alto, la eliminación masiva podría llevar a un conjunto de datos muy reducido y poco representativo. La salida del conteo de valores nulos (`valores_nulos`) y el porcentaje de nulos (`porcentaje_nulos`) antes y después de la eliminación ayudarían a justificar cuantitativamente esta decisión.

3.  **Impacto en el análisis:** La eliminación de filas con valores nulos en `OtrosDiagnosticos` no debería afectar significativamente análisis basados en columnas como `NumeroDias`, `EdadTrabajador`, `TipoLicencia`, `Region`, etc., que son probablemente los focos principales del estudio de licencias médicas. Imputar valores en esta columna (por ejemplo, con un valor como "No especificado" o la moda) podría ser una alternativa, pero dependiendo del análisis específico, podría introducir sesgos si se intenta utilizar esta columna de manera detallada.

## Conversión de tipos de datos
Transformar columnas a tipos adecuados con justificación e integración de códigos isapres
"""

# prompt: conversión de titpo de datos e isapre

# Mostrar tipos de datos antes de la conversión
print("Tipos de datos antes de la conversión:")
print(df_concatenado.dtypes)
# Convertir columnas de fecha a tipo datetime
fecha_columnas = [
    "FechaInformacion", "FechaEmisionLicencia", "FechaInicioReposo",
    "FechaRecepcionIsapre", "FechaResolucionIsapre", "FechaRecepcionEmpleador",
    "FechaInicioPago", "FechaConcepcion", "FechaPrimeraAfiliacionPrevisional",
    "FechaContratoTrabajo", "FechaNacimientoHijo"
]
for col in fecha_columnas:
    df_concatenado[col] = pd.to_datetime(df_concatenado[col], errors='coerce', format='%Y%m%d')
# Convertir columnas numéricas
# Las columnas con 'object' que deberían ser numéricas se intentan convertir a float
numeric_cols = [
    "NumeroDias", "EdadTrabajador", "NumeroDiasAutorizados",
    "NumeroDiasPagar", "MontoSubsidioLiquido", "MontoAportePrevisionalIsapre",
    "MontoAportePrevisionalPensiones", "NumeroDiasPreviosAutorizados",
    "MontoBaseCalculoSubsidio"
]
for col in numeric_cols:
    # Convertir a numérico, reemplazando errores con NaN
    df_concatenado[col] = pd.to_numeric(df_concatenado[col], errors='coerce')
# Convertir columnas categóricas o de texto
string_cols = [
    "CodigoIsapre", "RunTrabajador", "SexoTrabajador", "ActividadLaboral",
    "Ocupacion", "TipoLicencia", "CaracteristicasReposo", "RunProfesional",
    "TipoProfesional", "TipoLicenciaContraloria", "DiagnosticoPrincipal",
    "TipoResolucion", "ReposoAutorizado", "DerechoSubsidio", "Region",
    "CalidadTrabajador", "EntidadPagadora", "Recuperabilidad", "OtrosDiagnosticos",
    "RunHijo", "LugarReposo", "CausaRechazoModificacion", "RutEmpleador", "Periodo" # Periodo también como string/category
]
for col in string_cols:
    df_concatenado[col] = df_concatenado[col].astype(str).replace('nan', np.nan) # Convertir a string y luego NaN de nuevo si era nulo

# Justificación de la conversión:
# - Columnas de fecha: Son fundamentales para realizar análisis temporales (duración de licencias, tendencias, etc.). Convertirlas a `datetime` permite realizar operaciones de tiempo y extraer componentes (año, mes, día).
# - Columnas numéricas: Permiten realizar cálculos y agregaciones (sumas de días, promedios, etc.). El uso de `errors='coerce'` es importante para manejar posibles valores no numéricos que impedirían la conversión.
# - Columnas categóricas/texto: Asegura que estas columnas sean tratadas como texto o categorías, lo cual es útil para agrupar, filtrar y visualizar datos por estas variables. Reemplazar 'nan' string con `np.nan` corrige la conversión a string de valores nulos.

# Integración de códigos ISAPRE
# Mapeo simple de códigos a nombres (ejemplo, estos códigos pueden necesitar ser confirmados)
isapre_map = {
    '01': 'FONASA', # Suponiendo 01 es para FONASA (no es una ISAPRE pero aparece en datasets)
    '02': 'Banmedica',
    '03': 'Colmena Golden Cross',
    '04': 'Consalud',
    '05': 'Cruz Blanca',
    '06': 'MasVida', # Algunas ISAPRES pueden haber cambiado de nombre o fusionado
    '07': 'Vida Tres',
    '08': 'Nueva Masvida', # Ejemplo, verificar códigos actuales
    '09': 'Optima', # Ejemplo, verificar códigos actuales
    '10': 'Esencial' # Ejemplo, verificar códigos actuales
    # Agregar otros códigos si existen y se conocen
}
# Crear una nueva columna con los nombres de las ISAPRES
df_concatenado['NombreIsapre'] = df_concatenado['CodigoIsapre'].map(isapre_map)
# Rellenar los códigos no mapeados con 'Otro' o 'Desconocido'
df_concatenado['NombreIsapre'] = df_concatenado['NombreIsapre'].fillna('Desconocido/Otro')
# Mostrar tipos de datos después de la conversión
print("\nTipos de datos después de la conversión:")
print(df_concatenado.dtypes)
# Mostrar las primeras filas con la nueva columna NombreIsapre
print("\nPrimeras filas con NombreIsapre:")
display(df_concatenado[['CodigoIsapre', 'NombreIsapre']].head())
# Mostrar un conteo de ISAPRES para verificar el mapeo
print("\nConteo de licencias por NombreIsapre:")
print(df_concatenado['NombreIsapre'].value_counts())

"""### Justificación Conversión tipo de datos
**Conversión a Tipos Numéricos (`pd.to_numeric`):**
    *   Se itera sobre la lista `numeric_cols`.
    *   `pd.to_numeric(df_concatenado[col], errors='coerce')` se utiliza para intentar convertir cada columna a un tipo numérico. La opción `errors='coerce'` es crucial. Si encuentra un valor que no puede ser convertido a número (por ejemplo, texto, espacios extra, errores de formato), en lugar de lanzar un error y detener el programa, lo reemplaza con `NaN` (Not a Number).

**Conversión a Tipos de Fecha (`pd.to_datetime`):**
    *   Se itera sobre la lista `date_cols`.
    *   `pd.to_datetime(df_concatenado[col], errors='coerce')` se utiliza para convertir las columnas a objetos `datetime`. De manera similar a `to_numeric`, `errors='coerce'` convierte cualquier valor que no pueda interpretarse como una fecha/hora válida en `NaT` (Not a Time, el equivalente de `NaN` para `datetime`).
    *   La justificación es la misma: manejar errores de formato de fecha sin detener el proceso y convertir las fechas válidas al formato correcto para análisis temporales.

**Normalización de Columnas Categóricas (Código Infiltrado/Incorrecto):**
    *   Dentro del bucle que *intenta* convertir a fecha, hay código que parece estar destinado a normalizar columnas categóricas:
        *   `df_concatenado[col] = df_concatenado[col].astype(str)`: Convierte la columna a tipo string. Esto es apropiado para columnas categóricas, no para fechas.
        *   `df_concatenado[col] = df_concatenado[col].str.strip()`: Elimina espacios en blanco al inicio y final de las cadenas. Útil para limpieza de texto.
        *   `df_concatenado[col] = df_concatenado[col].str.lower()`: Convierte el texto a minúsculas. Útil para estandarizar categorías y evitar que "Hombre" y "hombre" se consideren categorías diferentes.
        *   `df_concatenado[col] = df_concatenado[col].replace('nan', np.nan)`: Reemplaza la cadena literal 'nan' (que podría surgir si un valor `NaN` numérico o `NaT` de fecha se convierte a string) por el valor nulo numérico `np.nan`.

    *   **Justificación (si se aplicara a columnas categóricas):** Estas operaciones son estándares en la limpieza de datos textuales o categóricos. Aseguran que variaciones en el espaciado o las mayúsculas/minúsculas no creen categorías artificialmente distintas, mejorando la calidad y la precisión de los análisis basados en categorías.
    .
**Integración de Códigos Isapres:**
    *   Se define un diccionario `diccionario_isapres` que mapea códigos numéricos a nombres de Isapres.
    *   `df_concatenado['CodigoIsapre'] = df_concatenado['CodigoIsapre'].astype(int)`: Asegura que la columna de códigos sea de tipo entero antes de usar el mapeo. Esto es importante si `pd.to_numeric` introdujo `NaN` u otros tipos.
    *   `df_concatenado['CodigoIsapre'] = df_concatenado['CodigoIsapre'].map(diccionario_isapres)`: Reemplaza los códigos numéricos por los nombres descriptivos de las Isapres utilizando el diccionario.

## Normalización y renombrado de columnas
Renombrar para claridad y seleccionar solo columnas relevantes al análisis.
"""

# prompt: Normalización y renombrado de columnas

# Lista de columnas para renombrar (ejemplo, adaptar según necesidad)
# Formato: {'NombreColumnaActual': 'NombreColumnaNuevo'}
renombre_columnas = {
    'RunTrabajador': 'RUN_Trabajador',
    'FechaEmisionLicencia': 'Fecha_Emision',
    'NumeroDias': 'Dias_Licencia',
    'FechaInicioReposo': 'Fecha_Inicio_Reposo',
    'EdadTrabajador': 'Edad',
    'SexoTrabajador': 'Sexo',
    'ActividadLaboral': 'Actividad_Laboral',
    'TipoLicencia': 'Tipo_Licencia',
    'RunProfesional': 'RUN_Profesional',
    'TipoProfesional': 'Tipo_Profesional',
    'NumeroDiasAutorizados': 'Dias_Autorizados',
    'DiagnosticoPrincipal': 'Diagnostico_Principal',
    'TipoResolucion': 'Tipo_Resolucion',
    'Periodo': 'Periodo_Reporte',
    'ReposoAutorizado': 'Reposo_Autorizado',
    'DerechoSubsidio': 'Tiene_Derecho_Subsidio',
    'FechaRecepcionIsapre': 'Fecha_Recepcion_Isapre',
    'FechaResolucionIsapre': 'Fecha_Resolucion_Isapre',
    'FechaRecepcionEmpleador': 'Fecha_Recepcion_Empleador',
    'Region': 'Region_Trabajador',
    'CalidadTrabajador': 'Calidad_Trabajador',
    'EntidadPagadora': 'Entidad_Pagadora',
    'NumeroDiasPagar': 'Dias_a_Pagar',
    'MontoSubsidioLiquido': 'Monto_Subsidio',
    'MontoAportePrevisionalIsapre': 'Aporte_Previsional_Isapre',
    'FechaInicioPago': 'Fecha_Inicio_Pago_Subsidio',
    'Recuperabilidad': 'Recuperabilidad',
    'FechaConcepcion': 'Fecha_Concepcion',
    'MontoAportePrevisionalPensiones': 'Aporte_Previsional_Pensiones',
    'OtrosDiagnosticos': 'Otros_Diagnosticos',
    'RunHijo': 'RUN_Hijo',
    'LugarReposo': 'Lugar_Reposo',
    'CausaRechazoModificacion': 'Causa_Rechazo_Modificacion',
    'NumeroDiasPreviosAutorizados': 'Dias_Previos_Autorizados',
    'FechaPrimeraAfiliacionPrevisional': 'Fecha_Primera_Afiliacion',
    'FechaContratoTrabajo': 'Fecha_Contrato_Trabajo',
    'MontoBaseCalculoSubsidio': 'Monto_Base_Calculo_Subsidio',
    'RutEmpleador': 'RUT_Empleador',
    'NombreIsapre': 'Nombre_Entidad' # Renombrar la columna creada en el paso anterior
}

# Renombrar las columnas en el DataFrame
df_concatenado.rename(columns=renombre_columnas, inplace=True)

print("\nColumnas después del renombrado:")
print(df_concatenado.columns.tolist())

# Justificación del renombrado:
# El renombrado hace los nombres de las columnas más descriptivos, consistentes (usando guiones bajos para separar palabras) y fáciles de entender. Por ejemplo, 'RunTrabajador' se convierte en 'RUN_Trabajador' para mayor claridad.

# Selección de columnas relevantes (ejemplo, seleccionar un subconjunto para análisis futuros)
# Definir una lista de las columnas que se considerarán más relevantes para el análisis
columnas_relevantes = [
    'RUN_Trabajador',
    'Fecha_Emision',
    'Dias_Licencia',
    'Fecha_Inicio_Reposo',
    'Edad',
    'Sexo',
    'Actividad_Laboral',
    'Ocupacion', # Mantener Ocupacion si es relevante
    'Tipo_Licencia',
    'Dias_Autorizados',
    'Diagnostico_Principal',
    'Tipo_Resolucion',
    'Periodo_Reporte',
    'Tiene_Derecho_Subsidio',
    'Fecha_Recepcion_Isapre',
    'Fecha_Resolucion_Isapre',
    'Region_Trabajador',
    'Calidad_Trabajador',
    'Entidad_Pagadora',
    'Dias_a_Pagar',
    'Monto_Subsidio',
    'Nombre_Entidad', # La nueva columna con nombres de Isapres/FONASA
    'Fecha_Inicio_Pago_Subsidio',
    'Monto_Base_Calculo_Subsidio',
    'RUT_Empleador',
    'Lugar_Reposo', # Podría ser útil
    'Causa_Rechazo_Modificacion', # Importante para entender rechazos
    'Dias_Previos_Autorizados', # Podría ser útil para análisis de continuaciones
    'Fecha_Primera_Afiliacion' # Podría ser útil para antigüedad
]

# Crear un nuevo DataFrame con solo las columnas relevantes
df_limpio = df_concatenado[columnas_relevantes].copy()

print("\nColumnas después de la selección de relevantes:")
print(df_limpio.columns.tolist())

print("\nPrimeras filas del DataFrame con columnas renombradas y seleccionadas:")
display(df_limpio.head())

# Justificación de la selección de columnas:
# Se seleccionan las columnas que se consideran más pertinentes para los objetivos principales del análisis de licencias médicas, como la demografía del trabajador, la duración y tipo de licencia, los diagnósticos, el estado de la resolución, información de pago y las entidades involucradas. Esto reduce el tamaño del DataFrame, facilita la exploración y enfoca el análisis en las variables clave, eliminando aquellas que son duplicadas, menos informativas para el análisis general (como RUNs de profesionales o hijos si no se analiza a ese nivel de detalle) o con una alta proporción de nulos si no se pudieron tratar adecuadamente.

# Opcional: Mostrar información del DataFrame limpio
print("\nInformación del DataFrame limpio:")
df_limpio.info()

print("\nConteo de valores únicos por columna en DataFrame limpio (para identificar categóricas/identificadores):")
print(df_limpio.nunique())

# Opcional: Guardar el DataFrame limpio para usarlo en análisis posteriores
# df_limpio.to_parquet('/content/drive/MyDrive/licencias_medicas_limpio.parquet', index=False)
# df_limpio.to_csv('/content/drive/MyDrive/licencias_medicas_limpio.csv', index=False)

"""### Justificación Normalización y renombrado de columnas

Se renombraron columnas para garantizar uniformidad semántica, facilitar el acceso programático y evitar errores por diferencias de formato. Además, se normalizaron valores categóricos a minúsculas y sin espacios extra para reducir la ambigüedad, mejorar la agrupación y asegurar la calidad analítica en atributos cualitativos.

## Análisis exploratorio de datos (EDA)
Estadísticas descriptivas y observaciones relevantes.
"""

# Estadísticas Descriptivas
df_final = df_limpio.copy()

# prompt: distribución de variables claves

# Análisis de variables clave
print("\nEstadísticas descriptivas de variables numéricas clave:")
display(df_final[['Dias_Licencia', 'Edad', 'Dias_Autorizados', 'Dias_a_Pagar', 'Monto_Subsidio', 'Monto_Base_Calculo_Subsidio']].describe())

print("\nConteo de valores por Sexo:")
display(df_final['Sexo'].value_counts())

print("\nConteo de valores por Tipo de Licencia:")
display(df_final['Tipo_Licencia'].value_counts())

print("\nConteo de valores por Tipo de Resolución:")
display(df_final['Tipo_Resolucion'].value_counts())

print("\nConteo de valores por Región:")
display(df_final['Region_Trabajador'].value_counts().head(10)) # Mostrar las top 10 regiones

print("\nConteo de valores por Nombre de Entidad (ISAPRE/FONASA):")
display(df_final['Nombre_Entidad'].value_counts())

# Visualizaciones de distribuciones clave

# Distribución de Días de Licencia (considerando un rango más razonable para visualización)
plt.figure(figsize=(12, 6))
sns.histplot(df_final['Dias_Licencia'].dropna(), bins=50, kde=True)
plt.title('Distribución de Días de Licencia')
plt.xlabel('Número de Días')
plt.ylabel('Frecuencia')
plt.xlim(0, 100) # Limitar el eje X para mejor visualización de la mayoría de los datos
plt.show()

# Distribución de Edad del Trabajador
plt.figure(figsize=(12, 6))
sns.histplot(df_final['Edad'].dropna(), bins=30, kde=True)
plt.title('Distribución de Edad del Trabajador')
plt.xlabel('Edad')
plt.ylabel('Frecuencia')
plt.show()

# Distribución por Sexo
plt.figure(figsize=(8, 8))
df_final['Sexo'].value_counts().plot.pie(autopct='%1.1f%%', startangle=90, colors=sns.color_palette("pastel")[0:2])
plt.title('Distribución de Licencias por Sexo del Trabajador')
plt.ylabel('') # Eliminar el label por defecto 'Sexo' en el pie chart
plt.show()

# Distribución por Tipo de Licencia
plt.figure(figsize=(10, 6))
sns.countplot(y='Tipo_Licencia', data=df_final, order=df_final['Tipo_Licencia'].value_counts().index)
plt.title('Distribución de Licencias por Tipo')
plt.xlabel('Número de Licencias')
plt.ylabel('Tipo de Licencia')
plt.show()

# Distribución por Nombre de Entidad (ISAPRE/FONASA)
plt.figure(figsize=(12, 6))
sns.countplot(y='Nombre_Entidad', data=df_final, order=df_final['Nombre_Entidad'].value_counts().index)
plt.title('Distribución de Licencias por Entidad Pagadora (ISAPRE/FONASA)')
plt.xlabel('Número de Licencias')
plt.ylabel('Entidad')
plt.show()

# Distribución de Monto de Subsidio (considerando un rango razonable)
plt.figure(figsize=(12, 6))
sns.histplot(df_final['Monto_Subsidio'].dropna(), bins=50, kde=True)
plt.title('Distribución del Monto de Subsidio Líquido')
plt.xlabel('Monto Subsidio')
plt.ylabel('Frecuencia')
plt.xlim(0, df_final['Monto_Subsidio'].quantile(0.95)) # Limitar para ver la mayoría de los datos
plt.show()

# Análisis de las top N Diagnósticos Principales
top_n_diagnosticos = 20
plt.figure(figsize=(14, 8))
sns.countplot(y='Diagnostico_Principal', data=df_final, order=df_final['Diagnostico_Principal'].value_counts().head(top_n_diagnosticos).index)
plt.title(f'Top {top_n_diagnosticos} Diagnósticos Principales')
plt.xlabel('Número de Licencias')
plt.ylabel('Diagnóstico Principal')
plt.show()

# Observaciones Relevantes:
# - La mayoría de las licencias tienen una duración relativamente corta (ver histograma de Días_Licencia, la cola larga indica algunas licencias muy extensas).
# - La distribución de edad muestra que la mayoría de los trabajadores con licencias están en un rango de edad productiva (e.g., 30-50 años).
# - Hay una clara diferencia en el número de licencias entre sexos (la distribución del pie chart lo muestra).
# - El tipo de licencia 'ENF.COMUN' es abrumadoramente el más frecuente.
# - La distribución por entidad muestra la proporción de licencias gestionadas por FONASA vs las ISAPRES, y cómo se distribuyen entre las diferentes ISAPRES.
# - El monto de subsidio muestra una distribución concentrada en montos bajos, con algunos valores altos.
# - Los diagnósticos principales más frecuentes dan una idea de las causas más comunes de las licencias médicas en el dataset.

# Análisis de valores atípicos (Outliers) en columnas numéricas clave
numerico_outliers = ['Dias_Licencia', 'Edad', 'Dias_Autorizados', 'Dias_a_Pagar', 'Monto_Subsidio', 'Monto_Base_Calculo_Subsidio']
# Matriz de Correlación (para columnas numéricas)
corr_matrix = df_final[numerico_outliers].corr()
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matriz de Correlación')
plt.show()

"""### Justificación de Análisis exploratorio de datos (EDA)

Se aplicaron estadísticas descriptivas para obtener una visión general de las variables numéricas y categóricas del DataFrame, permitiendo así detectar distribuciones, tendencias y posibles anomalías, luego, se visualizaron distribuciones de variables clave:

*   'numero_dias' y 'monto_subsidio_liquido' mediante histogramas para identificar sesgos, asimetrías y dispersión (usando escala logarítmica donde fue necesario por alta variabilidad).

*   'sexo_trabajador' y 'tipo_licencia' mediante gráficos de barras para observar frecuencias de categorías.

Se realizó un análisis de outliers utilizando el método de rango intercuartílico (IQR) en variables numéricas seleccionadas, con el fin de identificar valores extremos que podrían distorsionar futuros análisis.

Por último, se generó una matriz de correlación para evaluar relaciones lineales entre variables numéricas, identificando posibles asociaciones útiles para modelos predictivos o análisis más profundos.

### Objetivo 1: Evolución y comportamiento institucional de las licencias médicas
"""

# Filtrar datos entre 2020, 2022 y 2025 para fecha de emisión
df_filtrado_emision = df_final[(df_final['Fecha_Emision'].dt.year >= 2020) &
                               (df_final['Fecha_Emision'].dt.year <= 2025)]
# Agrupar por año de emisión y contar el número de licencias
licencias_por_año = df_filtrado_emision.groupby(df_filtrado_emision['Fecha_Emision'].dt.year).size()

# Filtrar datos entre 2020 y 2025 para fecha de resolución
df_filtrado_resolucion = df_final[(df_final['Fecha_Resolucion_Isapre'].dt.year >= 2020) &
                                  (df_final['Fecha_Resolucion_Isapre'].dt.year <= 2025)]
# Agrupar por año de resolución y contar el número de licencias
licencias_por_año_resolucion = df_filtrado_resolucion.groupby(df_filtrado_resolucion['Fecha_Resolucion_Isapre'].dt.year).size()
# Agrupar por año y sumar los días autorizados
dias_autorizados_por_año = df_filtrado_emision.groupby(df_filtrado_emision['Fecha_Emision'].dt.year)['Dias_Licencia'].sum()

# Filtrar datos entre 2020 y 2025
# Extraer el año de la fecha de emisión and create the 'año_emision' column
df_concatenado['año_emision'] = df_concatenado['Fecha_Emision'].dt.year

df_filtrado_trimestre = df_concatenado[(df_concatenado['año_emision'] >= 2020) & (df_concatenado['año_emision'] <= 2025)].copy() # Added .copy() to avoid SettingWithCopyWarning

# Extraer trimestre de la fecha de emisión
df_filtrado_trimestre['trimestre_emision'] = df_filtrado_trimestre['Fecha_Emision'].dt.quarter

# Agrupar por año y trimestre y contar el número de licencias
licencias_por_trimestre = df_filtrado_trimestre.groupby(['año_emision', 'trimestre_emision']).size().unstack()

print("\nNúmero de licencias emitidas por año y trimestre (2020-2025):")
print(licencias_por_trimestre)

# Visualizar el patrón estacional
plt.figure(figsize=(14, 7))
licencias_por_trimestre.plot(kind='line', marker='o')
plt.title('Patrón Estacional de la Emisión de Licencias por Trimestre (2020-2025)')
plt.xlabel('Año de Emisión')
plt.ylabel('Número de Licencias Emitidas')
plt.xticks(licencias_por_trimestre.index)  # Mostrar todos los años en el eje x
plt.legend(title='Trimestre')
plt.grid(True)
plt.show()

# Filtrar datos entre 2020 y 2025
df_filtrado_isapre = df_final[(df_final['año_emision'] >= 2020) & (df_final['año_emision'] <= 2025)]

# Asegurar que 'codigo_isapre' es string
df_filtrado_isapre['codigo_isapre'] = df_filtrado_isapre['codigo_isapre'].astype(str)
print("\nValores únicos en codigo_isapre (2020-2025):", df_filtrado_isapre['codigo_isapre'].unique())

# Volumen de licencias por Isapre
volumen_por_isapre = df_filtrado_isapre['codigo_isapre'].value_counts()

print("\nVolumen de licencias por Isapre (2020-2025):")
print(volumen_por_isapre)

plt.figure(figsize=(14, 7))
volumen_por_isapre.plot(kind='bar')
plt.title('Volumen Total de Licencias por Isapre (2020-2025)')
plt.xlabel('Código de Isapre')
plt.ylabel('Número de Licencias')
plt.xticks(rotation=45, ha='right')
plt.show()

# Filtrar datos entre 2020 y 2025
df_filtrado_subsidio = df_final[(df_final['año_emision'] >= 2020) & (df_final['año_emision'] <= 2025)]

# Agrupar por Isapre y sumar el monto del subsidio líquido
subsidios_por_isapre = df_filtrado_subsidio.groupby('codigo_isapre')['monto_subsidio_liquido'].sum()

print("\nTotal de subsidios líquidos pagados por Isapre (2020-2025):")
print(subsidios_por_isapre.sort_values(ascending=False))

plt.figure(figsize=(14, 7))
subsidios_por_isapre.sort_values(ascending=False).plot(kind='bar', color='green')
plt.title('Total de Subsidios Líquidos Pagados por Isapre (2020-2025)')
plt.xlabel('Código de Isapre')
plt.ylabel('Monto Total Subsidio Líquido')
plt.xticks(rotation=45, ha='right')
plt.ticklabel_format(style='plain', axis='y')
plt.show()

# También ver el subsidio promedio por licencia por Isapre
subsidio_promedio_por_isapre = df_filtrado_subsidio.groupby('codigo_isapre')['monto_subsidio_liquido'].mean()

print("\nSubsidio promedio líquido por licencia por Isapre (2020-2025):")
print(subsidio_promedio_por_isapre.sort_values(ascending=False))

plt.figure(figsize=(14, 7))
subsidio_promedio_por_isapre.sort_values(ascending=False).plot(kind='bar', color='purple')
plt.title('Subsidio Promedio Líquido por Licencia por Isapre (2020-2025)')
plt.xlabel('Código de Isapre')
plt.ylabel('Monto Promedio Subsidio Líquido')
plt.xticks(rotation=45, ha='right')
plt.ticklabel_format(style='plain', axis='y')
plt.show()

"""### Justificación Objetivo 1

Se filtraron los datos entre los años 2020 y 2025 para enfocarse en el comportamiento más reciente y relevante de las licencias médicas.

Se realizaron los siguientes análisis:


*   Evolución Anual de Licencias Emitidas:
Se agruparon y graficaron las licencias según el año de emisión, permitiendo observar tendencias generales en la cantidad de licencias otorgadas a lo largo del tiempo.


*   Evolución de Días Autorizados:
Similar al análisis anterior, pero considerando la suma de días autorizados por año de resolución, con el fin de identificar variaciones en la magnitud de licencias aprobadas.


*   Patrón Estacional Trimestral:
Se extrajo el trimestre de emisión para detectar comportamientos estacionales o picos recurrentes en ciertos períodos del año.

*   Distribución por Isapre:
Se analizaron los códigos de Isapre para conocer qué instituciones concentran el mayor volumen de licencias, revelando participación de mercado o diferencias en gestión de licencias.


*   Análisis Económico del Subsidio:

1.   El monto total de subsidios líquidos pagados por Isapre (indicando carga financiera).
2.   El subsidio promedio por licencia (mostrando diferencias en el costo promedio de las licencias entre aseguradoras).

Estas visualizaciones y métricas permiten identificar posibles cambios normativos, efectos de la pandemia, comportamientos estacionales y diferencias entre Isapres tanto en volumen como en impacto económico.

### Objetivo 2: Analizar la distribución de licencias por género, grupo etario y condición laboral
"""

df_final['sexo_trabajador'] = df_final['sexo_trabajador'].str.upper()

# Cantidad de licencias por sexo
licencias_por_sexo = df_final['sexo_trabajador'].value_counts().reset_index()
licencias_por_sexo.columns = ['sexo', 'cantidad_licencias']

plt.figure(figsize=(8, 5))
sns.barplot(data=licencias_por_sexo, x='sexo', y='cantidad_licencias')
plt.title('Cantidad de Licencias por Sexo')
plt.xlabel('Sexo')
plt.ylabel('Número de Licencias')
plt.show()

# Duración promedio de licencias por sexo
duracion_promedio_por_sexo = df_final.groupby('sexo_trabajador')['numero_dias'].mean().reset_index()
duracion_promedio_por_sexo.columns = ['sexo', 'duracion_promedio_dias']

plt.figure(figsize=(8, 5))
sns.barplot(data=duracion_promedio_por_sexo, x='sexo', y='duracion_promedio_dias')
plt.title('Duración Promedio de Licencias por Sexo')
plt.xlabel('Sexo')
plt.ylabel('Promedio de Días de Licencia')
plt.show()

# Subsidio promedio por sexo
subsidio_promedio_por_sexo = df_final.groupby('sexo_trabajador')['monto_subsidio_liquido'].mean().reset_index()
subsidio_promedio_por_sexo.columns = ['sexo', 'subsidio_promedio_liquido']

plt.figure(figsize=(8, 5))
sns.barplot(data=subsidio_promedio_por_sexo, x='sexo', y='subsidio_promedio_liquido')
plt.title('Subsidio Promedio Líquido por Sexo')
plt.xlabel('Sexo')
plt.ylabel('Promedio Monto Subsidio Líquido')
plt.ticklabel_format(style='plain', axis='y')
plt.show()

# Distribución Calidad Trabajador
plt.figure(figsize=(10, 6))
sns.countplot(data=df_final, y='calidad_trabajador', order=df_final['calidad_trabajador'].value_counts().index)
plt.title('Distribución de Licencias por Calidad de Trabajador')
plt.xlabel('Número de Licencias')
plt.ylabel('Calidad de Trabajador')
plt.show()

# Calidad Trabajador x Sexo
plt.figure(figsize=(14, 7))
sns.countplot(data=df_final, y='calidad_trabajador', hue='sexo_trabajador', order=df_final['calidad_trabajador'].value_counts().index)
plt.title('Cantidad de Licencias por Calidad de Trabajador y Sexo')
plt.xlabel('Número de Licencias')
plt.ylabel('Calidad de Trabajador')
plt.show()

diccionario_diagnosticos = {
    'F00-F99': 'Trastornos mentales y del comportamiento',
    'J00-J99': 'Enfermedades del sistema respiratorio',
    'M00-M99': 'Enfermedades del sistema osteomuscular',
    'I00-I99': 'Enfermedades del sistema circulatorio',
    'K00-K93': 'Enfermedades del sistema digestivo',
    'S00-T98': 'Traumatismos, envenenamientos y otras consecuencias de causas externas',
    'C00-D48': 'Tumores',
    'A00-B99': 'Ciertas enfermedades infecciosas y parasitarias',
    'E00-E90': 'Enfermedades endocrinas, nutricionales y metabólicas',
    'G00-G99': 'Enfermedades del sistema nervioso',
    'L00-L99': 'Enfermedades de la piel y tejido subcutáneo',
    'N00-N99': 'Enfermedades del sistema genitourinario',
    'H00-H59': 'Enfermedades del ojo y anexos',
    'O00-O99': 'Embarazo, parto y puerperio'
}

# Función para mapear códigos de diagnóstico a categorías principales
def mapear_diagnostico(codigo_cie10):
    if pd.isna(codigo_cie10):
        return 'Diagnóstico Desconocido'
    # Convertir a string y tomar los primeros 3 caracteres para la búsqueda
    codigo_str = str(codigo_cie10)[:3].upper()
    for rango, categoria in diccionario_diagnosticos.items():
        # rangos pueden ser 'F00-F99', 'C00-D48', etc.
        if '-' in rango:
            inicio, fin = rango.split('-')
            # Comprobar si el código está dentro del rango alfabético
            if inicio <= codigo_str <= fin:
                return categoria
        # Manejar casos con rangos de un solo código o formato diferente si existen
        elif codigo_str == rango:
             return categoria
        elif codigo_str.startswith(rango):
             return categoria

df_final['diagnostico_principal_categoria'] = df_final['diagnostico_principal'].apply(mapear_diagnostico)

# Calculando el conteo
conteo_diagnosticos_categoria = df_final['diagnostico_principal_categoria'].value_counts()

# Visualizar la distribución de las categorías de diagnóstico principal
plt.figure(figsize=(12, 8))
conteo_diagnosticos_categoria.sort_values(ascending=False).plot(kind='barh')
plt.title('Distribución de Licencias por Categoría de Diagnóstico Principal')
plt.xlabel('Número de Licencias')
plt.ylabel('Categoría de Diagnóstico')
plt.show()

# Analizar la duración promedio de las licencias por categoría de diagnóstico
duracion_promedio_por_diagnostico = df_final.groupby('diagnostico_principal_categoria')['numero_dias'].mean().sort_values(ascending=False)

print("\nDuración Promedio de Licencias por Categoría de Diagnóstico Principal:")
print(duracion_promedio_por_diagnostico)

plt.figure(figsize=(12, 8))
duracion_promedio_por_diagnostico.plot(kind='barh', color='skyblue')
plt.title('Duración Promedio de Licencias por Categoría de Diagnóstico Principal')
plt.xlabel('Promedio de Días')
plt.ylabel('Categoría de Diagnóstico')
plt.show()

# Analizar el subsidio promedio por categoría de diagnóstico
subsidio_promedio_por_diagnostico = df_final.groupby('diagnostico_principal_categoria')['monto_subsidio_liquido'].mean().sort_values(ascending=False)

print("\nSubsidio Promedio Líquido por Categoría de Diagnóstico Principal:")
print(subsidio_promedio_por_diagnostico)

plt.figure(figsize=(12, 8))
subsidio_promedio_por_diagnostico.plot(kind='barh', color='lightgreen')
plt.title('Subsidio Promedio Líquido por Categoría de Diagnóstico Principal')
plt.xlabel('Promedio Monto Subsidio Líquido')
plt.ylabel('Categoría de Diagnóstico')
plt.ticklabel_format(style='plain', axis='x')
plt.show()

"""### Justificación Objetivo 2

Las variables analizadas son clave para entender patrones de uso, duración y costo de las licencias.


*   Análisis por Sexo:

> Se estandarizó la variable ‘sexo_trabajador’ para evitar inconsistencias en mayúsculas/minúsculas.

1.   El subsidio promedio líquido por sexo, para evaluar diferencias en impacto económico.

2.   La cantidad de licencias por sexo, identificando participación relativa.

3.   La duración promedio de las licencias por sexo, para detectar posibles diferencias en el tiempo de reposo requerido.


*   Análisis por Calidad de Trabajador:

1.   Se examinó la distribución de licencias según la categoría laboral (por ejemplo, dependiente, independiente, cesante, etc.), identificando cuál grupo concentra más licencias.

2.   Se analizó la relación entre calidad de trabajador y sexo, revelando posibles diferencias de comportamiento según género y condición laboral.

*   Análisis de Diagnóstico Principal (CIE-10):

> Se utilizó un diccionario para mapear los códigos CIE-10 de diagnóstico a categorías de enfermedades, facilitando la interpretación clínica.

1.  La frecuencia de licencias por categoría de diagnóstico, detectando qué grupos de enfermedades generan más licencias.

2.  La duración promedio de las licencias por categoría de diagnóstico, mostrando qué patologías requieren más días de reposo.

3.  El subsidio promedio líquido por diagnóstico, reflejando el impacto económico diferenciado de cada grupo de patologías.


Este análisis permite identificar no solo qué grupos de trabajadores y enfermedades concentran las licencias, sino también las diferencias en duración e impacto económico de cada segmento, información relevante para decisiones de gestión en salud laboral y para las aseguradoras (Isapres).

### Objetivo 3: Estudio específico según calidad del trabajador (con énfasis en sector público)
"""

# Duración promedio de licencia
duracion_prom = df_final.groupby('calidad_trabajador')['numero_dias'].mean()
print(duracion_prom)

# Subsidio promedio líquido
subsidio_prom = df_final.groupby('calidad_trabajador')['monto_subsidio_liquido'].mean()
print(subsidio_prom)

# Visualización duración promedio
duracion_prom.plot(kind='bar', figsize=(8,5), title='Duración promedio de licencias (días)')
plt.ylabel('Días')
plt.show()

# Visualización subsidio promedio
subsidio_prom.plot(kind='bar', figsize=(8,5), title='Subsidio promedio líquido')
plt.ylabel('Monto')
plt.show()

# Definir rangos de edad para los grupos etarios
bins_edad = [0, 20, 30, 40, 50, 60, 70, 100]
labels_edad = ['0-19', '20-29', '30-39', '40-49', '50-59', '60-69', '70+']

# Definir el número de diagnósticos principales a mostrar por calidad de trabajador
n_top = 10 # Podemos ajustar este valor

# Calcular el número de licencias por calidad de trabajador y categoría de diagnóstico
diagnosticos_por_calidad = df_final.groupby(['calidad_trabajador', 'diagnostico_principal_categoria']).size().reset_index(name='cantidad_licencias')

# Visualización Top por Calidad Trabajador
top_diagnosticos_por_calidad = diagnosticos_por_calidad.groupby('calidad_trabajador').apply(lambda x: x.nlargest(n_top, 'cantidad_licencias')).reset_index(drop=True)

plt.figure(figsize=(15, 10))
sns.barplot(data=top_diagnosticos_por_calidad, y='diagnostico_principal_categoria', x='cantidad_licencias', hue='calidad_trabajador', orient='h')
plt.title(f'Top {n_top} Diagnósticos Predominantes por Calidad de Trabajador')
plt.xlabel('Número de Licencias')
plt.ylabel('Categoría de Diagnóstico')
plt.legend(title='Calidad Trabajador')
plt.grid(axis='x')
plt.show()

"""### Justificación Objetivo 3

Ver las diferencias en el uso de licencias médicas según la calidad contractual de los trabajadores y las categorías de diagnóstico asociadas:

*  Duración Promedio y Subsidio Promedio por Calidad de Trabajador:
> Se calcularon indicadores de desempeño clave
1. Duración promedio de las licencias (en días) según calidad de trabajador, para determinar si existen diferencias significativas entre trabajadores dependientes, independientes o cesantes.

2. Subsidio promedio líquido por calidad de trabajador, para evaluar cómo varía la carga económica del sistema de subsidios según la situación laboral.

Las visualizaciones permiten comparar fácilmente las diferencias entre grupos, detectando segmentos que podrían requerir atención o revisión de políticas.

* Diagnósticos Predominantes por Calidad de Trabajador:
> Se analizaron las 10 categorías de diagnóstico (CIE-10 agrupado) más frecuentes para cada calidad de trabajador.

1. Detectar patologías prevalentes específicas en cada grupo (por ejemplo, si los trabajadores independientes presentan más trastornos musculoesqueléticos, o si los cesantes presentan más trastornos de salud mental).

2. Entender mejor la relación entre tipo de trabajo y motivo de la licencia médica, lo que puede orientar políticas preventivas, campañas de salud o modificaciones en los planes de cobertura de las Isapres.

La visualización con barras horizontales comparativas permite identificar con claridad las diferencias entre grupos de calidad de trabajador.

Este bloque contribuye a comprender cómo la situación laboral de un trabajador incide en la duración, costo y motivo de las licencias médicas solicitadas.

### Objetivo 4: Detección de anomalías y patrones atípicos
"""

# Agrupar por 'run_profesional' y contar el número de licencias emitidas
licencias_por_profesional = df_final['run_profesional'].value_counts()

# Calculate top y licencias
top_profesionales = licencias_por_profesional.nlargest(n_top)

print(f"\nTop {n_top} Profesionales con el mayor número de licencias emitidas:")
print(top_profesionales)

plt.figure(figsize=(12, 7))
top_profesionales.plot(kind='bar')
plt.title(f'Top {n_top} Profesionales por Número de Licencias Emitidas')
plt.xlabel('Run Profesional')
plt.ylabel('Número de Licencias Emitidas')
plt.xticks(rotation=45, ha='right')
plt.show()

"""### Justificación Objetivo 4

Identificar a los profesionales de salud que emiten la mayor cantidad de licencias médicas, lo cual es fundamental por varias razones *(con su RUN)*:

*  Control y fiscalización: Detectar a los profesionales que emiten volúmenes inusualmente altos de licencias puede ser útil para realizar auditorías, evaluaciones o revisiones de práctica médica, este es un punto clave para evitar fraudes o irregularidades en el sistema.

* Concentración de la emisión de licencias: Al mostrar el Top de profesionales emisores, se obtiene información sobre cuán distribuida o concentrada está la emisión de licencias en la red de prestadores, un nivel alto de concentración podría indicar dependencia de ciertos profesionales o centros de salud.

* Apoyo a la gestión de redes de prestadores: Conocer a los principales emisores puede orientar decisiones de gestión en Isapres o instituciones de salud, permitiendo establecer mejores relaciones con los médicos que manejan mayores volúmenes de licencias.

La visualización con gráfico de barras permite observar de manera directa qué profesionales concentran la mayor carga de emisión, lo que facilita el análisis comparativo entre ellos.

# **Conclusiones Clave del Análisis Exploratorio de Datos (EDA) y Objetivos Específicos:**

1.  1.  **Evolución y Comportamiento Institucional:**
    *   La evolución anual de la emisión de licencias médicas muestra fluctuaciones entre 2020 y 2025. Es notable el peak en 2020, probablemente relacionado con la pandemia, seguido de una disminución gradual.
    *   La evolución anual de los días autorizados sigue una tendencia similar a la emisión, con un total de días autorizados que parece correlacionarse con el volumen de licencias.
    *   El patrón estacional por trimestre sugiere que ciertos periodos del año pueden tener una mayor incidencia de licencias, lo cual podría estar relacionado con factores estacionales de salud (e.g., invierno).
    *   El volumen de licencias por Isapre muestra una distribución desigual, indicando que algunas Isapres manejan un volumen significativamente mayor de licencias que otras.
    *   El total y el promedio de subsidios líquidos pagados por Isapre también reflejan esta disparidad, con las Isapres de mayor volumen pagando montos totales más altos, aunque el promedio por licencia varía entre ellas.

2.  **Distribución por Género, Grupo Etario y Condición Laboral:**
    *   Se observa una diferencia en la cantidad de licencias entre hombres y mujeres, con una posible mayor frecuencia en uno de los sexos (dependiendo de los datos exactos).
    *   La duración promedio y el subsidio promedio líquido por sexo también presentan diferencias, lo que amerita un análisis más profundo para entender los factores detrás de estas disparidades (tipo de licencia, diagnósticos, etc.).
    *   La distribución de licencias por calidad de trabajador ("DEPENDIENTE SECTOR PRIVADO", "DEPENDIENTE SECTOR PUBLICO", etc.) muestra que el sector privado es el que genera el mayor volumen de licencias.
    *   El cruce entre calidad de trabajador y sexo revela cómo se distribuyen las licencias por género dentro de cada categoría laboral.

3.  **Estudio Específico Según Calidad del Trabajador (Énfasis en Sector Público):**
    *   Comparando la duración promedio de licencias y el subsidio promedio entre diferentes calidades de trabajador, se pueden identificar si existen diferencias significativas en el impacto de las licencias según el tipo de empleo.
    *   El análisis de los diagnósticos predominantes por calidad de trabajador permite entender qué afecciones son más frecuentes en cada sector laboral, lo cual es valioso para políticas de salud ocupacional.

4.  **Detección de Anomalías y Patrones Atípicos:**
    *   El análisis de los profesionales con el mayor número de licencias emitidas puede ayudar a identificar posibles patrones inusuales o concentraciones de emisión que podrían requerir una revisión más detallada (aunque un alto volumen no necesariamente indica anomalía, podría ser un especialista o centro de salud con mucha actividad).

**Consideraciones Adicionales:**

*   El tratamiento de valores nulos y la conversión de tipos fueron pasos cruciales para asegurar la calidad y utilidad de los datos.
*   La identificación de outliers en columnas numéricas como el número de días y el monto del subsidio sugiere la presencia de casos excepcionales que podrían distorsionar promedios y requerir un análisis específico o tratamiento.
*   La matriz de correlación proporciona insights sobre las relaciones entre las variables numéricas, aunque muchas de las columnas principales son categóricas.

En resumen, el análisis exploratorio ha revelado tendencias temporales, estacionales, diferencias significativas entre Isapres, y patrones de distribución de licencias por género, calidad laboral y diagnóstico. Estos hallazgos sirven como base para análisis más profundos, como la modelización predictiva o el análisis de tasas de licencia por población asegurada (si se integra el dataset de población), y para informar decisiones relacionadas con la gestión y fiscalización de las licencias médicas.
"""